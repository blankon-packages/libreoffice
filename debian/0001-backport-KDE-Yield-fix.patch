From e565749b3acbd767218039557d47d68a0dbcb52f Mon Sep 17 00:00:00 2001
From: Rene Engelhard <rene@debian.org>
Date: Tue, 11 Feb 2014 11:53:32 +0100
Subject: [PATCH] backport KDE Yield fix

---
 changelog                  |    3 ++
 patches/kde-yield-fix.diff |   70 ++++++++++++++++++++++++++++++++++++++++++++
 patches/series             |    1 +
 3 files changed, 74 insertions(+)
 create mode 100644 patches/kde-yield-fix.diff

diff --git a/changelog b/changelog
index 29c315e..9099f9f 100644
--- a/changelog
+++ b/changelog
@@ -1,5 +1,8 @@
 libreoffice (1:4.1.4-3) UNRELEASED; urgency=low
 
+  * debian/patches/kde-yield-fix.diff: backport patch from LO 4.2.0 which
+    rewrites Qt4 based nested yield mutex locking (closes: #728987, #723087)
+
   * debian/control.ure.in:
     - add missing second a in "additional" (closes: #734512) 
   * debian/pom.*.xml.in, debian/*.poms, debian/rules:
diff --git a/patches/kde-yield-fix.diff b/patches/kde-yield-fix.diff
new file mode 100644
index 0000000..add04a4
--- /dev/null
+++ b/patches/kde-yield-fix.diff
@@ -0,0 +1,70 @@
+From 8b4775458600dc2a2e8eb17e0bade35221c6b2ea Mon Sep 17 00:00:00 2001
+From: Jan-Marek Glogowski <glogow@fbihome.de>
+Date: Thu, 21 Nov 2013 11:40:57 +0000
+Subject: fdo#67011: Run Display::Yield through KDEXLib::Yield.
+
+Drag'n'Drop is handled in a second thread, which tries to "yield
+the display" while the main Qt thread probably is already
+yielding. Both need the YieldMutex, which freezes the application
+until the D'n'D thread times out.
+
+Trying to yield the display throught the application yield
+results in a recursive loop.
+
+So this catches and breaks the recursion, but just inside the Qt
+thread, so other processes can "yield on the display", instead
+of simply disabling the Display::Yield.
+
+Change-Id: Ifba91aa89fe5b0a89cc94820935dc996a065112f
+Reviewed-on: https://gerrit.libreoffice.org/6750
+Tested-by: Jan-Marek Glogowski <glogow@fbihome.de>
+Reviewed-by: Jan-Marek Glogowski <glogow@fbihome.de>
+---
+diff --git a/vcl/unx/kde4/KDESalDisplay.cxx b/vcl/unx/kde4/KDESalDisplay.cxx
+index 21440fc..ee330e7 100644
+--- a/vcl/unx/kde4/KDESalDisplay.cxx
++++ b/vcl/unx/kde4/KDESalDisplay.cxx
+@@ -25,6 +25,8 @@
+ #include <assert.h>
+ #include <unx/saldata.hxx>
+ 
++#include <qthread.h>
++
+ SalKDEDisplay* SalKDEDisplay::selfptr = NULL;
+ 
+ SalKDEDisplay::SalKDEDisplay( Display* pDisp )
+@@ -48,18 +50,26 @@ SalKDEDisplay::~SalKDEDisplay()
+ 
+ void SalKDEDisplay::Yield()
+ {
+-    if( DispatchInternalEvent() )
++    // We yield the display throught the main Qt thread.
++    // Actually this Yield may call the Display::Yield, which results in an
++    // unlimited cycle.
++    static bool break_cyclic_yield_recursion = false;
++    bool is_qt_gui_thread = ( qApp->thread() == QThread::currentThread() );
++
++    if( DispatchInternalEvent() || break_cyclic_yield_recursion )
+         return;
+ 
++    if( is_qt_gui_thread )
++        break_cyclic_yield_recursion = true;
++
+     DBG_ASSERT( static_cast<SalYieldMutex*>(GetSalData()->m_pInstance->GetYieldMutex())->GetThreadId() ==
+                 osl::Thread::getCurrentIdentifier(),
+                 "will crash soon since solar mutex not locked in SalKDEDisplay::Yield" );
+ 
+-    XEvent event;
+-    XNextEvent( pDisp_, &event );
+-    if( checkDirectInputEvent( &event ))
+-        return;
+-    qApp->x11ProcessEvent( &event );
++    static_cast<KDEXLib*>(GetXLib())->Yield( true, false );
++
++    if( is_qt_gui_thread )
++        break_cyclic_yield_recursion = false;
+ }
+ 
+ // HACK: When using Qt event loop, input methods (japanese, etc.) will get broken because
+--
+cgit v0.9.0.2-2-gbebe
diff --git a/patches/series b/patches/series
index 83e82cf..09c8c45 100644
--- a/patches/series
+++ b/patches/series
@@ -33,3 +33,4 @@ qadevOOo-kfreebsd.diff
 fix-system-bluez.diff
 unopkg-SHARED-quote.diff
 disable-ftp-nohost-test.diff
+kde-yield-fix.diff
-- 
1.7.10.4

